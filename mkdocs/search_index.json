{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Flask-Base Documentation\n\n\nSource Code\n\n\nSee \nthe Github repository\n\n\nPurpose\n\n\nThis guide is meant to be a mix between formal and explanatory documentation. \n\n\nSynopsis\n\n\nA Flask application template with the boilerplate code already done for you.\n\n\nWhat's included?\n\n\n\n\nBlueprints\n\n\nUser and permissions management\n\n\nFlask-SQLAlchemy for databases\n\n\nFlask-WTF for forms\n\n\nFlask-Assets for asset management and SCSS compilation\n\n\nFlask-Mail for sending emails\n\n\ngzip compression\n\n\ngulp autoreload for quick static page debugging\n\n\n\n\nFormatting code\n\n\nBefore you submit changes to flask-base, you may want to auto format your code with \npython manage.py format\n.\n\n\nContributing\n\n\nSee \nthe Github repository\n\n\nLicense\n\n\nMIT License", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-flask-base-documentation", 
            "text": "", 
            "title": "Welcome to Flask-Base Documentation"
        }, 
        {
            "location": "/#source-code", 
            "text": "See  the Github repository", 
            "title": "Source Code"
        }, 
        {
            "location": "/#purpose", 
            "text": "This guide is meant to be a mix between formal and explanatory documentation.", 
            "title": "Purpose"
        }, 
        {
            "location": "/#synopsis", 
            "text": "A Flask application template with the boilerplate code already done for you.", 
            "title": "Synopsis"
        }, 
        {
            "location": "/#whats-included", 
            "text": "Blueprints  User and permissions management  Flask-SQLAlchemy for databases  Flask-WTF for forms  Flask-Assets for asset management and SCSS compilation  Flask-Mail for sending emails  gzip compression  gulp autoreload for quick static page debugging", 
            "title": "What's included?"
        }, 
        {
            "location": "/#formatting-code", 
            "text": "Before you submit changes to flask-base, you may want to auto format your code with  python manage.py format .", 
            "title": "Formatting code"
        }, 
        {
            "location": "/#contributing", 
            "text": "See  the Github repository", 
            "title": "Contributing"
        }, 
        {
            "location": "/#license", 
            "text": "MIT License", 
            "title": "License"
        }, 
        {
            "location": "/setup/", 
            "text": "Setting up\n\n\nClone the repo\n\n\n$ git clone https://github.com/hack4impact/flask-base.git\n$ cd flask-base\n\n\n\n\nInitialize a virtualenv\n\n\n$ pip install virtualenv\n$ virtualenv env\n$ source env/bin/activate\n\n\n\n\n(If you're on a mac) Make sure xcode tools are installed\n\n\n$ xcode-select --install\n\n\n\n\nAdd Environment Variables\n\n\nCreate a file called \n.env\n that contains environment variables in the following syntax: \nENVIRONMENT_VARIABLE=value\n. For example,\nthe mailing environment variables can be set as the following\n\n\nMAIL_USERNAME=example@domain.com\nMAIL_PASSWORD=SuperSecretPassword\nSECRET_KEY=SuperRandomStringToBeUsedForEncryption\n\n\n\n\nNote: do not include the \n.env\n file in any commits. This should remain private.\n\n\nInstall the dependencies\n\n\n$ pip install -r requirements/common.txt\n$ pip install -r requirements/dev.txt\n\n\n\n\nOther dependencies for running locally\n\n\nYou need to install \nForeman\n and \nRedis\n. Chances are, these commands will work:\n\n\n$ gem install foreman\n\n\n\n\nMac (using \nhomebrew\n):\n\n\n$ brew install redis\n\n\n\n\nLinux:\n\n\n$ sudo apt-get install redis-server\n\n\n\n\nCreate the database\n\n\n$ python manage.py recreate_db\n\n\n\n\nOther setup (e.g. creating roles in database)\n\n\n$ python manage.py setup_dev\n\n\n\n\nNote that this will create an admin user with email and password specified by the \nADMIN_EMAIL\n and \nADMIN_PASSWORD\n config variables. If not specified, they are both \nflask-base-admin@example.com\n and \npassword\n respectively.\n\n\n[Optional] Add fake data to the database\n\n\n$ python manage.py add_fake_data\n\n\n\n\n[Optional. Only valid on \ngulp-static-watcher\n branch] Use gulp to live compile your files\n\n\n\n\nInstall the Live Reload browser plugin from \nhere\n\n\nRun \nnpm install\n\n\nRun \ngulp\n\n\n\n\nRunning the app\n\n\n$ source env/bin/activate\n$ foreman start -f Local", 
            "title": "Setup"
        }, 
        {
            "location": "/setup/#setting-up", 
            "text": "", 
            "title": "Setting up"
        }, 
        {
            "location": "/setup/#clone-the-repo", 
            "text": "$ git clone https://github.com/hack4impact/flask-base.git\n$ cd flask-base", 
            "title": "Clone the repo"
        }, 
        {
            "location": "/setup/#initialize-a-virtualenv", 
            "text": "$ pip install virtualenv\n$ virtualenv env\n$ source env/bin/activate", 
            "title": "Initialize a virtualenv"
        }, 
        {
            "location": "/setup/#if-youre-on-a-mac-make-sure-xcode-tools-are-installed", 
            "text": "$ xcode-select --install", 
            "title": "(If you're on a mac) Make sure xcode tools are installed"
        }, 
        {
            "location": "/setup/#add-environment-variables", 
            "text": "Create a file called  .env  that contains environment variables in the following syntax:  ENVIRONMENT_VARIABLE=value . For example,\nthe mailing environment variables can be set as the following  MAIL_USERNAME=example@domain.com\nMAIL_PASSWORD=SuperSecretPassword\nSECRET_KEY=SuperRandomStringToBeUsedForEncryption  Note: do not include the  .env  file in any commits. This should remain private.", 
            "title": "Add Environment Variables"
        }, 
        {
            "location": "/setup/#install-the-dependencies", 
            "text": "$ pip install -r requirements/common.txt\n$ pip install -r requirements/dev.txt", 
            "title": "Install the dependencies"
        }, 
        {
            "location": "/setup/#other-dependencies-for-running-locally", 
            "text": "You need to install  Foreman  and  Redis . Chances are, these commands will work:  $ gem install foreman  Mac (using  homebrew ):  $ brew install redis  Linux:  $ sudo apt-get install redis-server", 
            "title": "Other dependencies for running locally"
        }, 
        {
            "location": "/setup/#create-the-database", 
            "text": "$ python manage.py recreate_db", 
            "title": "Create the database"
        }, 
        {
            "location": "/setup/#other-setup-eg-creating-roles-in-database", 
            "text": "$ python manage.py setup_dev  Note that this will create an admin user with email and password specified by the  ADMIN_EMAIL  and  ADMIN_PASSWORD  config variables. If not specified, they are both  flask-base-admin@example.com  and  password  respectively.", 
            "title": "Other setup (e.g. creating roles in database)"
        }, 
        {
            "location": "/setup/#optional-add-fake-data-to-the-database", 
            "text": "$ python manage.py add_fake_data", 
            "title": "[Optional] Add fake data to the database"
        }, 
        {
            "location": "/setup/#optional-only-valid-on-gulp-static-watcher-branch-use-gulp-to-live-compile-your-files", 
            "text": "Install the Live Reload browser plugin from  here  Run  npm install  Run  gulp", 
            "title": "[Optional. Only valid on gulp-static-watcher branch] Use gulp to live compile your files"
        }, 
        {
            "location": "/setup/#running-the-app", 
            "text": "$ source env/bin/activate\n$ foreman start -f Local", 
            "title": "Running the app"
        }, 
        {
            "location": "/manage_commands/", 
            "text": "Manage.py and Commands\n\n\npython manage.py runserver\n\n\nA note about python manage.py runserver. Runserver is\nactually located in flask.ext.script. Since we\nhave not specified a runserver command, it defaults to\nflask.ext.script's Server() method which calls the native\nflask method app.run(). You can pass in some arguemnts such\nas changing the port on which the server is run.\n\n\n.env\n\n\nThe following code block will look for a '.env' file which\ncontains environment variables for things like email address\nand any other env vars. The .env file will be parsed and\nsantized. Each line contains some \"NAME=VALUE\" pair. Split\nthis and then store var[0] = \"NAME\" and var[1] = \"VALUE\".\nThen formally set the environment variable in the last line of\nthis block. Per our running example, os.environ[\"NAME\"] = \"VALUE\"\nThese environment variables can be accessed with \"os.getenv('KEY')\"\n\n\nif os.path.exists('.env'):\n    print('Importing environment from .env file')\n    for line in open('.env'):\n        var = line.strip().split('=')\n        if len(var) == 2:\n            os.environ[var[0]] = var[1]\n\n\n\n\nConfig and \ncreate_app\n\n\nRefer to \nmanage.py\n for more details. \n\n\napp = create_app(os.getenv('FLASK_CONFIG') or 'default')\nmanager = Manager(app)\nmigrate = Migrate(app, db)\n\n\n\n\nCurrently the application will\nlook for an environment variable called \nFLASK_CONFIG\n or it will\nmove to the 'default' configuration which is the DevelopmentConfig\n(again see \nmanage.py\n for full details). Next it will call the\n\ncreate_app\n method found in \napp/__init__.py\n. This method takes in a\nname of a configuration and finds the configuration settings in\nconfig.py. In heroku this will be set to 'production' i.e.\nProductionConfig. \n\n\nNext a \nManager\n instance is created. Manager\nis basically a nice plugin(?) that will allow us to get some useful\nfeedback when we call \nmanage.py\n from the command line. It also handles\nall the \nmanage.py\n commands. The \n@manager.command\n and \n@manager.option(...)\n\ndecorators are used to determine what the help output should be\non the terminal. Migrate is used to make migration between db instances\nreally easy. Additionally \n@manager.command\n creates an application\ncontext for use of plugins that are usually tied to the app.\n\n\nMake Shell Context\n\n\ndef make_shell_context():\n    return dict(app=app, db=db, User=User, Role=Role)\n\nmanager.add_command('shell', Shell(make_context=make_shell_context))\nmanager.add_command('db', MigrateCommand)\n\n\n\n\nMake shell context doesn't really serve a ton of purpose in most of our\ndevelopment at h4i. However, it is entirely possible to explore the database\nfrom the command line with this as seen in the lines above.\n\n\nIt is possible to create a general app shell or database specific shell.\nFor example doing 'python manage.py shell'\n\n\n$ me = User()\n$ db.session.add(me) \n db.session.commit()\n$ me.id\n\n 1\n\n\n\n\nThis basically creates a new user object, commits it to the database gives\nit a id. The db specific shell exposes the native MigrateCommands...\nhonestly you won't have to worry about these and future info can\nbe found the Flask-Migrate documentation.\n\n\nRecreate db\n\n\n@manager.command\ndef recreate_db():\n    \n\n    Recreates a local database. You probably should not use this on\n    production. EDIT: SHOULD NOT USE THIS IN PRODUCTION!!!\n    \n\n    db.drop_all()\n    db.create_all()\n    db.session.commit()\n\n\n\n\nSo this will clear out all the user data (drop_all), will create a new\ndatabase but with all the tables and columns set up per your models.\ncreate_all() and drop_all() rely upon the fact that you have imported\n\n ALL YOUR DATABASE MODELS \n. If you are seeing some table not being\ncreated this is the most likely culprit.\n\n\nRun Worker + Redis\n\n\nThe run_worker command will initialize a task queue. This is basically a\nlist of operations stored in memory that the server will get around to doing\neventually. This is great for doing asynchronous tasks. The memory store\nused for holding these tasks is called Redis. We set up a default redis\npassword and then open a connection to the redis DB. We instantiate a worker\nand add a queue of items that needs to be processed on that worker.\n\n\n@manager.command\ndef run_worker():\n    \nInitializes a slim rq task queue.\n\n    listen = ['default']\n    conn = Redis(\n        host=app.config['RQ_DEFAULT_HOST'],\n        port=app.config['RQ_DEFAULT_PORT'],\n        db=0,\n        password=app.config['RQ_DEFAULT_PASSWORD']\n    )\n\n    with Connection(conn):\n        worker = Worker(map(Queue, listen))\n        worker.work()\n\n\n\n\nMisc\n\n\nYou may/may not know this but the whole\nif \nname\n == '\nmain\n' check is to see if this file is being executed\ndirectly rather than indirectly (by being imported through another file).\nSo when we execute this file directly (by running python manage.py SOMECMD)\nwe get the option of instatiating the manager instance\nThese methods should be accessible from other\nfiles though if imported. \n HAVE NOT TESTED THIS THEORY OUT\nBut you would have a tough time executing these commands from cmd line\nwithout the Manager init (otherwise you have to deal with argvs and\nstuff that is frankly tedious).", 
            "title": "Commands"
        }, 
        {
            "location": "/manage_commands/#managepy-and-commands", 
            "text": "", 
            "title": "Manage.py and Commands"
        }, 
        {
            "location": "/manage_commands/#python-managepy-runserver", 
            "text": "A note about python manage.py runserver. Runserver is\nactually located in flask.ext.script. Since we\nhave not specified a runserver command, it defaults to\nflask.ext.script's Server() method which calls the native\nflask method app.run(). You can pass in some arguemnts such\nas changing the port on which the server is run.", 
            "title": "python manage.py runserver"
        }, 
        {
            "location": "/manage_commands/#env", 
            "text": "The following code block will look for a '.env' file which\ncontains environment variables for things like email address\nand any other env vars. The .env file will be parsed and\nsantized. Each line contains some \"NAME=VALUE\" pair. Split\nthis and then store var[0] = \"NAME\" and var[1] = \"VALUE\".\nThen formally set the environment variable in the last line of\nthis block. Per our running example, os.environ[\"NAME\"] = \"VALUE\"\nThese environment variables can be accessed with \"os.getenv('KEY')\"  if os.path.exists('.env'):\n    print('Importing environment from .env file')\n    for line in open('.env'):\n        var = line.strip().split('=')\n        if len(var) == 2:\n            os.environ[var[0]] = var[1]", 
            "title": ".env"
        }, 
        {
            "location": "/manage_commands/#config-and-create_app", 
            "text": "Refer to  manage.py  for more details.   app = create_app(os.getenv('FLASK_CONFIG') or 'default')\nmanager = Manager(app)\nmigrate = Migrate(app, db)  Currently the application will\nlook for an environment variable called  FLASK_CONFIG  or it will\nmove to the 'default' configuration which is the DevelopmentConfig\n(again see  manage.py  for full details). Next it will call the create_app  method found in  app/__init__.py . This method takes in a\nname of a configuration and finds the configuration settings in\nconfig.py. In heroku this will be set to 'production' i.e.\nProductionConfig.   Next a  Manager  instance is created. Manager\nis basically a nice plugin(?) that will allow us to get some useful\nfeedback when we call  manage.py  from the command line. It also handles\nall the  manage.py  commands. The  @manager.command  and  @manager.option(...) \ndecorators are used to determine what the help output should be\non the terminal. Migrate is used to make migration between db instances\nreally easy. Additionally  @manager.command  creates an application\ncontext for use of plugins that are usually tied to the app.", 
            "title": "Config and create_app"
        }, 
        {
            "location": "/manage_commands/#make-shell-context", 
            "text": "def make_shell_context():\n    return dict(app=app, db=db, User=User, Role=Role)\n\nmanager.add_command('shell', Shell(make_context=make_shell_context))\nmanager.add_command('db', MigrateCommand)  Make shell context doesn't really serve a ton of purpose in most of our\ndevelopment at h4i. However, it is entirely possible to explore the database\nfrom the command line with this as seen in the lines above.  It is possible to create a general app shell or database specific shell.\nFor example doing 'python manage.py shell'  $ me = User()\n$ db.session.add(me)   db.session.commit()\n$ me.id  1  This basically creates a new user object, commits it to the database gives\nit a id. The db specific shell exposes the native MigrateCommands...\nhonestly you won't have to worry about these and future info can\nbe found the Flask-Migrate documentation.", 
            "title": "Make Shell Context"
        }, 
        {
            "location": "/manage_commands/#recreate-db", 
            "text": "@manager.command\ndef recreate_db():\n     \n    Recreates a local database. You probably should not use this on\n    production. EDIT: SHOULD NOT USE THIS IN PRODUCTION!!!\n     \n    db.drop_all()\n    db.create_all()\n    db.session.commit()  So this will clear out all the user data (drop_all), will create a new\ndatabase but with all the tables and columns set up per your models.\ncreate_all() and drop_all() rely upon the fact that you have imported  ALL YOUR DATABASE MODELS  . If you are seeing some table not being\ncreated this is the most likely culprit.", 
            "title": "Recreate db"
        }, 
        {
            "location": "/manage_commands/#run-worker-redis", 
            "text": "The run_worker command will initialize a task queue. This is basically a\nlist of operations stored in memory that the server will get around to doing\neventually. This is great for doing asynchronous tasks. The memory store\nused for holding these tasks is called Redis. We set up a default redis\npassword and then open a connection to the redis DB. We instantiate a worker\nand add a queue of items that needs to be processed on that worker.  @manager.command\ndef run_worker():\n     Initializes a slim rq task queue. \n    listen = ['default']\n    conn = Redis(\n        host=app.config['RQ_DEFAULT_HOST'],\n        port=app.config['RQ_DEFAULT_PORT'],\n        db=0,\n        password=app.config['RQ_DEFAULT_PASSWORD']\n    )\n\n    with Connection(conn):\n        worker = Worker(map(Queue, listen))\n        worker.work()", 
            "title": "Run Worker + Redis"
        }, 
        {
            "location": "/manage_commands/#misc", 
            "text": "You may/may not know this but the whole\nif  name  == ' main ' check is to see if this file is being executed\ndirectly rather than indirectly (by being imported through another file).\nSo when we execute this file directly (by running python manage.py SOMECMD)\nwe get the option of instatiating the manager instance\nThese methods should be accessible from other\nfiles though if imported.   HAVE NOT TESTED THIS THEORY OUT\nBut you would have a tough time executing these commands from cmd line\nwithout the Manager init (otherwise you have to deal with argvs and\nstuff that is frankly tedious).", 
            "title": "Misc"
        }, 
        {
            "location": "/config/", 
            "text": "Configuration Commands and \nconfig.py\n\n\nSo lets go through each of the configuring variables.\n\n\nAPP_NAME is the name of the app. This is used in templating\nto make sure that all the pages at least have the same html\ntitle\n\n\nSECRET_KEY is a alpha-numeric string that is used for crypto\nrelated things in some parts of the application. Set it as an\nenvironment variable or default to our insecure one. This is\nused in password hashing see app/models/user.py for more info.\nYOU SHOULD SET THIS AS A CONFIG VAR IN PRODUCTION!!!!\n\n\nSQLALCHEMY_COMMIT_ON_TEARDOWN is used to auto-commit any sessions\nthat are open at the end of the 'app context' or basically the\ncurrent request on the application. But it is best practice\nto go ahead and commit after any db.session is created\n\n\nSSL_DISABLE I unfortunately do not know much about ;(. But something\nrealated to https\n\n\nMAIL_... is used for basic mailing server connectivity throug the\nSMTP protocol. This is further described in email.py.", 
            "title": "Configuration"
        }, 
        {
            "location": "/config/#configuration-commands-and-configpy", 
            "text": "So lets go through each of the configuring variables.  APP_NAME is the name of the app. This is used in templating\nto make sure that all the pages at least have the same html\ntitle  SECRET_KEY is a alpha-numeric string that is used for crypto\nrelated things in some parts of the application. Set it as an\nenvironment variable or default to our insecure one. This is\nused in password hashing see app/models/user.py for more info.\nYOU SHOULD SET THIS AS A CONFIG VAR IN PRODUCTION!!!!  SQLALCHEMY_COMMIT_ON_TEARDOWN is used to auto-commit any sessions\nthat are open at the end of the 'app context' or basically the\ncurrent request on the application. But it is best practice\nto go ahead and commit after any db.session is created  SSL_DISABLE I unfortunately do not know much about ;(. But something\nrealated to https  MAIL_... is used for basic mailing server connectivity throug the\nSMTP protocol. This is further described in email.py.", 
            "title": "Configuration Commands and config.py"
        }, 
        {
            "location": "/init/", 
            "text": "__init__.py\n\n\nCSRF Protection\n\n\nNote about CSRF protection. This basically prevents hackers\nfrom being able to post to our POST routes without having actually\nloaded a form on our website. E.g. they could potentially create\nusers if they found out the URL for our register routes and\nthe params we expect (its fairly easy to do). But with\nCSRF protection, all forms have a hidden field that is verified on\nour end. This is a bit low level, but there is a SESSION object\nstored on the flask server in memory. Each user has their\nown session containing things like their username, password, etc\nWhen a form created, a random string called a CSRF token is\ncreated and is sent along with the form in a hidden field.\nSimultaneously, this string is added to the user session\nstored on the server. When the user submits a form, then\nthe server will check to see if the hidden form field with the\nCSRF token matches the CSRF token stored in the user's session\non the server. If it does, then everything is fine and the\nPOST request can proceed normally. If not, then the POST request\nis aborted as a 403 (i think) error is thrown...basically\nthe user is not able to POST. This is great for forms, but\nif you want to create a public API that does not require a session,\nthen you'll want to include a decorator on your route \n@csrf.exempt\n\n\nFlask-Login\n\n\nlogin_manager = LoginManager()\nlogin_manager.session_protection = 'strong'\nlogin_manager.login_view = 'account.login'\n\n\n\n\nFlask-login provides us with a bunch of easy ways to do secure and\nsimple login techniques. LoginManager() is the main class that\nwill handle all of this. Session protection makes sure the\nuser session is very secure and login_manager.login_view\nIs the view that the a non-authenticated user will get redirected\nto. Otherwise it is a 401 error.\n\n\ninit_app(app)\n\n\nmail.init_app(app)\ndb.init_app(app)\nlogin_manager.init_app(app)\ncsrf.init_app(app)\ncompress.init_app(app)\nRQ(app)\n\n\n\n\ninit_app(app) are methods in each of these packages\nMore on init_app. It binds each instance of the respective\napplication to the flask app. However, we do need to specify\nan application context while using things like db, mail,\nlogin_manager, and compress since they are not bound to our\napplication \nexclusively\n.\n\n\nSet up Asset Pipeline\n\n\nThis one is a bit complex. First an Environment instance is created\nthat holds references to a single path to the 'static' folder. We don't\nreally care about that since the url_for() method allows us to specify\naccess to resources in the static/ directory. But we then append all the\nfolders and files within the 'dirs' array to the environment. This\naction provides context for the subsequence set of register actions.\nLooking in app/assets.py there are some Bundle instances created with\n3 parameters mainly: what type of file(s) to bundle, a type of filter/\ntranspiler to apply, and then a final output file. E.g. for the\napp_css bundle, it looks within assets/styles, assets/scripts for any\n*.scss files, converts them to css with the scss transpiler and then\noutputs it to the styles/app.css file.\nSee the templates/partials/_head.html\nfile for more information on how to actually include the file.\n\n\nBlueprints\n\n\nfrom account import account as account_blueprint\nfrom admin import admin as admin_blueprint\nfrom main import main as main_blueprint\n\napp.register_blueprint(main_blueprint)\napp.register_blueprint(account_blueprint, url_prefix='/account')\napp.register_blueprint(admin_blueprint, url_prefix='/admin')\n\n\n\n\nBlueprints allow us to set up url prefixes for routes contained\nwithin the views file of each of the divisions we specify to be\nregistered with a blueprint. Blueprints are meant to distinguish between\nthe variable different bodies within a large application.\nIn the case of flask-base, we have 'main', 'account', and 'admin'\nsections. The 'main' section contains error handling and views.\nThe other sections contain mainly just views. The folders for each of\nthese sections also contain an \ninit\n file which actually creates the\nBlueprint itself with a name and a default \nname\n param as well.\nAfter that, the views file and any other files that depend upon the\nblueprint are imported and can use the variable name assigned to the\nblueprint to reference things like decorators for routes. e.g. if my\nblueprint is name 'first_component', I would use the following as\na decorator for my routes '@first_component.route'. By specifying\nthe url_prefix, all of the functions and routes etc of the blueprint\nwill be read with the base url_prefix specified. E.g. if I wanted\nto access the '/blah' route within the 'acount' blueprint, I need only\nspecify @account.router('/blah') def ... as my method in views.py under\nthe account/ directory. But I would be able to access it in the\nbrowser with yourdomain.com/accounts/blah\n\n\n\n\nA note on why we are importing here: Because stuff will break...and for\na good reason! The account import in turn imports the views.py file under\nthe account/ directory. The views.py in turn references db\ndb is the database instance which was created after the import statements\nIf we had included these import statements at the very top, views.py\nunder account would have refered to a db instance which was not created!\nhence errors...all the errors (at least in files relying upon a created\ndb instance...and any instance created beyond that.", 
            "title": "Initialization"
        }, 
        {
            "location": "/init/#__init__py", 
            "text": "", 
            "title": "__init__.py"
        }, 
        {
            "location": "/init/#csrf-protection", 
            "text": "Note about CSRF protection. This basically prevents hackers\nfrom being able to post to our POST routes without having actually\nloaded a form on our website. E.g. they could potentially create\nusers if they found out the URL for our register routes and\nthe params we expect (its fairly easy to do). But with\nCSRF protection, all forms have a hidden field that is verified on\nour end. This is a bit low level, but there is a SESSION object\nstored on the flask server in memory. Each user has their\nown session containing things like their username, password, etc\nWhen a form created, a random string called a CSRF token is\ncreated and is sent along with the form in a hidden field.\nSimultaneously, this string is added to the user session\nstored on the server. When the user submits a form, then\nthe server will check to see if the hidden form field with the\nCSRF token matches the CSRF token stored in the user's session\non the server. If it does, then everything is fine and the\nPOST request can proceed normally. If not, then the POST request\nis aborted as a 403 (i think) error is thrown...basically\nthe user is not able to POST. This is great for forms, but\nif you want to create a public API that does not require a session,\nthen you'll want to include a decorator on your route  @csrf.exempt", 
            "title": "CSRF Protection"
        }, 
        {
            "location": "/init/#flask-login", 
            "text": "login_manager = LoginManager()\nlogin_manager.session_protection = 'strong'\nlogin_manager.login_view = 'account.login'  Flask-login provides us with a bunch of easy ways to do secure and\nsimple login techniques. LoginManager() is the main class that\nwill handle all of this. Session protection makes sure the\nuser session is very secure and login_manager.login_view\nIs the view that the a non-authenticated user will get redirected\nto. Otherwise it is a 401 error.", 
            "title": "Flask-Login"
        }, 
        {
            "location": "/init/#init_appapp", 
            "text": "mail.init_app(app)\ndb.init_app(app)\nlogin_manager.init_app(app)\ncsrf.init_app(app)\ncompress.init_app(app)\nRQ(app)  init_app(app) are methods in each of these packages\nMore on init_app. It binds each instance of the respective\napplication to the flask app. However, we do need to specify\nan application context while using things like db, mail,\nlogin_manager, and compress since they are not bound to our\napplication  exclusively .", 
            "title": "init_app(app)"
        }, 
        {
            "location": "/init/#set-up-asset-pipeline", 
            "text": "This one is a bit complex. First an Environment instance is created\nthat holds references to a single path to the 'static' folder. We don't\nreally care about that since the url_for() method allows us to specify\naccess to resources in the static/ directory. But we then append all the\nfolders and files within the 'dirs' array to the environment. This\naction provides context for the subsequence set of register actions.\nLooking in app/assets.py there are some Bundle instances created with\n3 parameters mainly: what type of file(s) to bundle, a type of filter/\ntranspiler to apply, and then a final output file. E.g. for the\napp_css bundle, it looks within assets/styles, assets/scripts for any\n*.scss files, converts them to css with the scss transpiler and then\noutputs it to the styles/app.css file.\nSee the templates/partials/_head.html\nfile for more information on how to actually include the file.", 
            "title": "Set up Asset Pipeline"
        }, 
        {
            "location": "/init/#blueprints", 
            "text": "from account import account as account_blueprint\nfrom admin import admin as admin_blueprint\nfrom main import main as main_blueprint\n\napp.register_blueprint(main_blueprint)\napp.register_blueprint(account_blueprint, url_prefix='/account')\napp.register_blueprint(admin_blueprint, url_prefix='/admin')  Blueprints allow us to set up url prefixes for routes contained\nwithin the views file of each of the divisions we specify to be\nregistered with a blueprint. Blueprints are meant to distinguish between\nthe variable different bodies within a large application.\nIn the case of flask-base, we have 'main', 'account', and 'admin'\nsections. The 'main' section contains error handling and views.\nThe other sections contain mainly just views. The folders for each of\nthese sections also contain an  init  file which actually creates the\nBlueprint itself with a name and a default  name  param as well.\nAfter that, the views file and any other files that depend upon the\nblueprint are imported and can use the variable name assigned to the\nblueprint to reference things like decorators for routes. e.g. if my\nblueprint is name 'first_component', I would use the following as\na decorator for my routes '@first_component.route'. By specifying\nthe url_prefix, all of the functions and routes etc of the blueprint\nwill be read with the base url_prefix specified. E.g. if I wanted\nto access the '/blah' route within the 'acount' blueprint, I need only\nspecify @account.router('/blah') def ... as my method in views.py under\nthe account/ directory. But I would be able to access it in the\nbrowser with yourdomain.com/accounts/blah", 
            "title": "Blueprints"
        }, 
        {
            "location": "/assets/", 
            "text": "Assets\n\n\n(refer to \nflask-base/app/assets.py\n)\n\n\nSee app/\ninit\n.py for details on this\n\n\ncontext is set as the assets/styles and\nassetts/scripts folders\n\n\nfilter = scss -\n convers .scss to css\nfilter = jsmin -\n converts to minified\n                  javascript\n\n\nBundle is just the plugin that helps us\ndo this task.\n\n\nDecorators\n\n\ndef permission_required(permission):\n    \nRestrict a view to users with the given permission.\n\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.can(permission):\n                abort(403)\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\n\n\n\n\nThis is a rather complicated function, but the general idea\nis that it will allow is to create a decorator that will\nkick users to a 403 page if they dont have a certain permission\nor let them continue. First there is a permission_required\nmethod which takes in a permission e.g. Permission.ADMINISTER\nThen it create a function called 'decorator' which performs\nthe check in a separate function itself decorates called\n'decorated_function'. It returns the result from\n'decorate_function' as well as the results from a specified\nparameter f that serves as an extra function call. The\n@wraps(f) decorator is itself used to give context for the\ndecorated function and actually point that context towards\nthe fully decorated function when the permission_required()\ndecorator is invoked. Tl;dr it does some complicated stuff\nyou don't really need to know about\n\n\n@admin_required\n\n\ndef admin_required(f):\n    return permission_required(Permission.ADMINISTER)(f)\n\n\n\n\nThis is a decorator created by the permission required decorator\nIt checks if the current_user is an admin or not. It takes in a\nfunction f as the next action to occur after the check happens\nhowever in practice, we only use the decorator @admin_required\non routes.", 
            "title": "Assets and Decorators"
        }, 
        {
            "location": "/assets/#assets", 
            "text": "(refer to  flask-base/app/assets.py )  See app/ init .py for details on this  context is set as the assets/styles and\nassetts/scripts folders  filter = scss -  convers .scss to css\nfilter = jsmin -  converts to minified\n                  javascript  Bundle is just the plugin that helps us\ndo this task.", 
            "title": "Assets"
        }, 
        {
            "location": "/assets/#decorators", 
            "text": "def permission_required(permission):\n     Restrict a view to users with the given permission. \n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.can(permission):\n                abort(403)\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator  This is a rather complicated function, but the general idea\nis that it will allow is to create a decorator that will\nkick users to a 403 page if they dont have a certain permission\nor let them continue. First there is a permission_required\nmethod which takes in a permission e.g. Permission.ADMINISTER\nThen it create a function called 'decorator' which performs\nthe check in a separate function itself decorates called\n'decorated_function'. It returns the result from\n'decorate_function' as well as the results from a specified\nparameter f that serves as an extra function call. The\n@wraps(f) decorator is itself used to give context for the\ndecorated function and actually point that context towards\nthe fully decorated function when the permission_required()\ndecorator is invoked. Tl;dr it does some complicated stuff\nyou don't really need to know about", 
            "title": "Decorators"
        }, 
        {
            "location": "/assets/#admin_required", 
            "text": "def admin_required(f):\n    return permission_required(Permission.ADMINISTER)(f)  This is a decorator created by the permission required decorator\nIt checks if the current_user is an admin or not. It takes in a\nfunction f as the next action to occur after the check happens\nhowever in practice, we only use the decorator @admin_required\non routes.", 
            "title": "@admin_required"
        }, 
        {
            "location": "/models/", 
            "text": "Models\n\n\nPermission\n class\n\n\nGENERAL = 0x01\nADMINISTER = 0xff\n\n\n\n\nOkay so here is a seemingly simple piece of code I really think is\nreally cool! First of all we are setting up two enums here.\nBut they are set to weird hexadecimal numbers 0x01 and 0xff.\nIf you stick these into a hexadecimal -\n decimal converter\nyou'll find that they represent 1 and 255 respectively. But\nin binary they come out to 00000001 and 11111111 (8 ones).\nIf we do a binary and (\n) on these two numbers, we can\nactually get some unique properties from these.\nSo if we do GENERAL \n ADMINSTER, it will come out to the following\n\n\n  00000001\n\n 11111111\n----------\n  00000001\n\n\n\n\nWe get back the exact same value as GENERAL! Similarly if we do\nADMINSTER \n GENERAL we get back GENERAL. This is useful for\nchecking user roles and who is exactly who in this system.\nSo we can create a method 'check(input, checker)' that will\ntake an input hex to test and one to text against. We only need\nto do '(input \n checker) == checker'. But there are some more\ninteresting applications for this. Let us define, for example,\na set of enums CAN_LIKE = 0x01, CAN_POST = 0x02, CAN_EDIT = 0x04\nand CAN_REMOVE = 0x08. These are respectively in binary 00000001,\n00000010, 00000100, 00001000. We can use binary OR (|) to create\ncomposite user permissions e.g. CAN_LIKE | CAN_POST | CAN_EDIT =\n0x07 = 00000111 -\n NEW_ROLE. We can run 'check(NEW_ROLE, CAN_LIKE)'\nor 'check(NEW_ROLE, CAN_POST)' or 'check(NEW_ROLE, CAN_EDIT)' and\nall of these will return True.\nFor example NEW_ROLE \n CAN_EDIT\n\n\n  00000111\n\n 00000001\n----------\n  00000001 \n- equivalent to CAN_EDIT enum\n\n\n\n\nA function similar to the check described above can be found in\nas the 'can' method below in the User class. Moving on!\n\n\nRole\n class\n\n\nThe Role class instatiates Role model. This is used for the\ncreation of users such as a general user and an administrator\n\n\nCOLUMN DEFINITIONS:\n\n\nid\n serves as the primary key (expects int).\n\n\nname\n is the name of the role itself (expects unique String len 64)\n\n\nindex\n is the name of the index route for the route \n\n\ndefault\n is a T/F value that determines whether a new user created\n  has that permission or note (ref insert_roles()). This is indexed\n  meaning that a separate table has been created with default as the\n  first column and id as the second column. Default in this table\n  is sorted and a query for default performs a binary search rather\n  than a linear search (reduces search time complexity from \nO(N)\n to\n  \nO(log n)\n\n\npermissions\n contains the permissions enum (see Permissions class)\n\n\nusers\n is not a column but it sets up a database relation. This case\n  is a one-to-many relationship in that for ONE Role record, there are\n  MANY associated User objects. The \nbackref\n param specifies a\n  bi-directional relationship between the two tables in that there is\n  a new property on both a given Role and User object. E.g. Role.users\n  will refer to the User object (i.e. the user table). and User.role\n  (role being the string specified with backref) will refer to the\n  Role object. Lazy = dynamic specifies to return a Query object\n  instead of actually asking the relationship to load all of its child\n  elements upon creating the relationship. It is best practice to\n  include lazy=dynamic upon the establishment of a relationship.\n\n\nSub-note on lazy-dynamic and backref:\n\n\nCurrently, lazy-dynamic will\nmake the User collection to be loaded in as a Query object (so not\neverything is loaded at once). Simiarly (as mentioned above), the\nUser object can reference the Role object by doing User.role however,\nthis uses the default collection loading behavior (i.e. load the entire\ncollection at once). It is fine in this case since the amount of\nRoles in the Role collection will be \nmuch\n less than the amount of\nentries in the User collection. However, we can specify that User.role\nuses the lazy-dynamic loading scheme. Simply redefine users here to\n\n\nusers = db.relationship('User', backref=db.backref('role',\n                                      lazy='dynamic'), lazy='dynamic')\n\n\n\n\ninsert_roles() and SQLAlchemy Sessions\n\n\nThe staticmethod decorator specifies that insert_roles() must be\nbe called with a instance of the Role class. E.g. role_obj.insert_roles()\nThis method is fairly self-explanatory. It specifies a 'roles' dict\nThis is then iterated through and foreach role in the 'roles' dict\nwe check to see if it already exists (by name) in the Role object\ni.e. the Roles table. If not, then a new Role object is instantiated\nAfter that, the perms, index, default props are set and the the\nrole object is now added to the db session and then committed.\n\n\nA note about sqlalchemy if you haven't noticed already: All changes\nare added to a Session object (handled by SQLAlchemy). Unless specified\notherwise, the session object has a merge operation that finds the difs\nbetween the new object (that was created and added to the session object)\nand the currently existing (corresponding) object existing in the table\nright now. Then a commit() propegates these changes into the database\nmaking as little changes as possible (i.e. every time we update a\nrecord, the record's attribute is changed 'in place' rather than being\ndeleted and then replaced. Neat :)\n\n\n__repr__\n\n\ndef __repr__(self):\n    return '\nRole \\'%s\\'\n' % self.name\n\n\n\n\nthis \nrepr\n method is pretty much optional, but it is helpful in that\nit will allow the program to pretty print the user object when you come\nacross an error\n\n\nUser\n Model\n\n\nThe class User represents users... it extends db.Model and\nUserMixin. Per the flask-login documentation, the User class\nneeds to implement is_authenticated (returns True if the user is\nauthenticated and in turn fulfill login_required), is_active\n(returns True if the user has been activated i.e. confirmed by\nemail in our case), is_anonymous (returns if a user is Anonymous\ni.e. is_active = is_authenticated = False, is_anonymous = True,\nand get_id() = None), get_id() (returns a UNICODE that has the\nid of the user NOT an int).\n\n\nColumn Descriptions:\n\n\nid\n - primary key for the table. Id of the user. i.e. the\n  unique identifier for the collection\n\n\nconfirmed\n - boolean val (default value = False) that is\n  an indication of whether the user has confirmed their\n  account via email.\n\n\nfirst_name\n - ... string self explanatory\n\n\nlast_name\n - ... string self explanatory\n\n\nemail\n - string self explanatory. But we impose the uniqueness\n  constraint on this column. It is necessary to check for this\n  on the backend before entering an email into the table,\n  else there will be some nasty errors produced when the user\n  tries to add an existing email into the table.\n\n\nNote: first_name, last_name, email form an index table for easy lookup. See Role for more info\n\n\npassword_hash\n is a 128 char long string containing the hashed\n  password. As always, it is best practice to never include the\n  plaintext password on the server. This hashed password is\n  checked against when authenticating users.\n\n\nrole_id\n is the id of the role the user is. It is a foreign key\n  and relates to the id's in the Role collection. By default\n  the general user is role.id = 1, and role.id = 2 is the\n  admin. Also note that we refer to the Role collection with\n  'roles' rather than the assigned backref 'role' since we\n  are referring to an individual column.\n\n\nOther User Class Variables and Methods\n\n\nNote that the following methods are actually available in your Jinja\ntemplates since they are attached to the user instance.\n\n\nfull_name\n provides the full name of the user given a first and last\n  name\n\n\ncan\n provides a really cool way of determining whether a user has\n  given permissions. See the Permissions class for more info.\n\nis_admin\n is an implementation of \ncan\n to test a user against\n  admin permissions.\n\n\npassword\n This does not give a password if a user just\n  calls the method and throws an AttributeError. However\n  if someone chooses to set a password e.g.\n  u = User( password = \ntest\n ) the second definition of\n  password method is run, taking the keyword arg (kwarg) as the\n  password to then call the generate_password_hash method and\n  set the password_hash property of the user to the generated\n  password.\n\n\nverify_password\n well...verifies a provided user plaintext password\n  against the password_hash in the user record. Uses the\n  check_password_hash method.\n\n\ngenerate_confirmation_token\n returns a cryptographically signed\n  string with encrypted user id under key \nconfirm\n. This will\n  expire in 7 days. Note that Serializer is actually\n  TimedJSONWebSerializer when looking for documentation.\n\n\ngenerate_changed_email_token\n also returns a cryptographically\n  signed string with encrypted user id under key \nchange_email\n\n  and a encrypted new_email parameter password into the method\n  containing the desired new email the user wants to replace the\n  old email with.\n\n\ngenerate_password_reset_token\n operates similarly to \ngenerate_\n  confirmation_token\n. Generates token for password reset\n\n\nNOTE: For context, the generate_..._token methods are used to create\na random string that will be later added to an email (usually) to the\nrequesting user.\n\n\nconfirm_account\n\n\nThe confirm_account method will take in a token (which was presumably\ngenerated from the generate_confirmation_token method) and then return\nTrue if the provided token is valid (and can be decrypted with the\nSECRET_KEY and has not expired) AND the decrypted token has the key\n'confirm' with the id of the requesting user. If so, it flips the\n'confirmed' attribute of the requesting user to True.\nWill throw BadSignature of the token is invalid, will throw\nSignatureExpired if the token is past the expiration time.\n\n\nchange_email\n\n\nThe change_email method will take in a token (which was presumably\ngenerated from the generate_email_token method) and then return True\nTrue if the token is valid (see above method for explanation of 'valid')\nand contains the key 'change_email' with value = user id in addition to\nthe key 'new_email' with the new email address the user wants to change\ntheir email to. Before the new_email is committed to the session, a\nquery is performed on the User collection on all the emails to maintain\nthe unique constraint on the email columns. Then the user's 'email'\nattribute is set to the 'new_email' specified in the decrypted token.\nwill throw BadSignature if invalid token and SignatureExpired if the\ntoken is expired.\n\n\nAnonymousUser\n\n\nWe define a custom AnonymousUser class that represents a non-logged\nuser. It extends the AnonymousUserMixing provided by flask-loginmanager\nwe deny all permissions and affirm that this user is not an admin\n\n\nclass AnonymousUser(AnonymousUserMixin):\n    def can(self, _):\n        return False\n\n    def is_admin(self):\n        return False\n\n\n\n\nlogin_manager.anonymous_user = AnonymousUser\n\n\n\n\nWe then register our custom AnonymousUser class as the default login_manager\nanonymous user class\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))\n\n\n\n\nThis is the default user_loader method for login_manager. This method\ndefines how to query for a user given a user_id from the user SESSION object.\nIt is pretty straightforward, it will query the User table and find the user\nwith ID equal to the user_id provided in the user SESSION", 
            "title": "Models"
        }, 
        {
            "location": "/models/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/models/#permission-class", 
            "text": "GENERAL = 0x01\nADMINISTER = 0xff  Okay so here is a seemingly simple piece of code I really think is\nreally cool! First of all we are setting up two enums here.\nBut they are set to weird hexadecimal numbers 0x01 and 0xff.\nIf you stick these into a hexadecimal -  decimal converter\nyou'll find that they represent 1 and 255 respectively. But\nin binary they come out to 00000001 and 11111111 (8 ones).\nIf we do a binary and ( ) on these two numbers, we can\nactually get some unique properties from these.\nSo if we do GENERAL   ADMINSTER, it will come out to the following    00000001  11111111\n----------\n  00000001  We get back the exact same value as GENERAL! Similarly if we do\nADMINSTER   GENERAL we get back GENERAL. This is useful for\nchecking user roles and who is exactly who in this system.\nSo we can create a method 'check(input, checker)' that will\ntake an input hex to test and one to text against. We only need\nto do '(input   checker) == checker'. But there are some more\ninteresting applications for this. Let us define, for example,\na set of enums CAN_LIKE = 0x01, CAN_POST = 0x02, CAN_EDIT = 0x04\nand CAN_REMOVE = 0x08. These are respectively in binary 00000001,\n00000010, 00000100, 00001000. We can use binary OR (|) to create\ncomposite user permissions e.g. CAN_LIKE | CAN_POST | CAN_EDIT =\n0x07 = 00000111 -  NEW_ROLE. We can run 'check(NEW_ROLE, CAN_LIKE)'\nor 'check(NEW_ROLE, CAN_POST)' or 'check(NEW_ROLE, CAN_EDIT)' and\nall of these will return True.\nFor example NEW_ROLE   CAN_EDIT    00000111  00000001\n----------\n  00000001  - equivalent to CAN_EDIT enum  A function similar to the check described above can be found in\nas the 'can' method below in the User class. Moving on!", 
            "title": "Permission class"
        }, 
        {
            "location": "/models/#role-class", 
            "text": "The Role class instatiates Role model. This is used for the\ncreation of users such as a general user and an administrator", 
            "title": "Role class"
        }, 
        {
            "location": "/models/#column-definitions", 
            "text": "id  serves as the primary key (expects int).  name  is the name of the role itself (expects unique String len 64)  index  is the name of the index route for the route   default  is a T/F value that determines whether a new user created\n  has that permission or note (ref insert_roles()). This is indexed\n  meaning that a separate table has been created with default as the\n  first column and id as the second column. Default in this table\n  is sorted and a query for default performs a binary search rather\n  than a linear search (reduces search time complexity from  O(N)  to\n   O(log n)  permissions  contains the permissions enum (see Permissions class)  users  is not a column but it sets up a database relation. This case\n  is a one-to-many relationship in that for ONE Role record, there are\n  MANY associated User objects. The  backref  param specifies a\n  bi-directional relationship between the two tables in that there is\n  a new property on both a given Role and User object. E.g. Role.users\n  will refer to the User object (i.e. the user table). and User.role\n  (role being the string specified with backref) will refer to the\n  Role object. Lazy = dynamic specifies to return a Query object\n  instead of actually asking the relationship to load all of its child\n  elements upon creating the relationship. It is best practice to\n  include lazy=dynamic upon the establishment of a relationship.", 
            "title": "COLUMN DEFINITIONS:"
        }, 
        {
            "location": "/models/#sub-note-on-lazy-dynamic-and-backref", 
            "text": "Currently, lazy-dynamic will\nmake the User collection to be loaded in as a Query object (so not\neverything is loaded at once). Simiarly (as mentioned above), the\nUser object can reference the Role object by doing User.role however,\nthis uses the default collection loading behavior (i.e. load the entire\ncollection at once). It is fine in this case since the amount of\nRoles in the Role collection will be  much  less than the amount of\nentries in the User collection. However, we can specify that User.role\nuses the lazy-dynamic loading scheme. Simply redefine users here to  users = db.relationship('User', backref=db.backref('role',\n                                      lazy='dynamic'), lazy='dynamic')", 
            "title": "Sub-note on lazy-dynamic and backref:"
        }, 
        {
            "location": "/models/#insert_roles-and-sqlalchemy-sessions", 
            "text": "The staticmethod decorator specifies that insert_roles() must be\nbe called with a instance of the Role class. E.g. role_obj.insert_roles()\nThis method is fairly self-explanatory. It specifies a 'roles' dict\nThis is then iterated through and foreach role in the 'roles' dict\nwe check to see if it already exists (by name) in the Role object\ni.e. the Roles table. If not, then a new Role object is instantiated\nAfter that, the perms, index, default props are set and the the\nrole object is now added to the db session and then committed.  A note about sqlalchemy if you haven't noticed already: All changes\nare added to a Session object (handled by SQLAlchemy). Unless specified\notherwise, the session object has a merge operation that finds the difs\nbetween the new object (that was created and added to the session object)\nand the currently existing (corresponding) object existing in the table\nright now. Then a commit() propegates these changes into the database\nmaking as little changes as possible (i.e. every time we update a\nrecord, the record's attribute is changed 'in place' rather than being\ndeleted and then replaced. Neat :)", 
            "title": "insert_roles() and SQLAlchemy Sessions"
        }, 
        {
            "location": "/models/#__repr__", 
            "text": "def __repr__(self):\n    return ' Role \\'%s\\' ' % self.name  this  repr  method is pretty much optional, but it is helpful in that\nit will allow the program to pretty print the user object when you come\nacross an error", 
            "title": "__repr__"
        }, 
        {
            "location": "/models/#user-model", 
            "text": "The class User represents users... it extends db.Model and\nUserMixin. Per the flask-login documentation, the User class\nneeds to implement is_authenticated (returns True if the user is\nauthenticated and in turn fulfill login_required), is_active\n(returns True if the user has been activated i.e. confirmed by\nemail in our case), is_anonymous (returns if a user is Anonymous\ni.e. is_active = is_authenticated = False, is_anonymous = True,\nand get_id() = None), get_id() (returns a UNICODE that has the\nid of the user NOT an int).", 
            "title": "User Model"
        }, 
        {
            "location": "/models/#column-descriptions", 
            "text": "id  - primary key for the table. Id of the user. i.e. the\n  unique identifier for the collection  confirmed  - boolean val (default value = False) that is\n  an indication of whether the user has confirmed their\n  account via email.  first_name  - ... string self explanatory  last_name  - ... string self explanatory  email  - string self explanatory. But we impose the uniqueness\n  constraint on this column. It is necessary to check for this\n  on the backend before entering an email into the table,\n  else there will be some nasty errors produced when the user\n  tries to add an existing email into the table.  Note: first_name, last_name, email form an index table for easy lookup. See Role for more info  password_hash  is a 128 char long string containing the hashed\n  password. As always, it is best practice to never include the\n  plaintext password on the server. This hashed password is\n  checked against when authenticating users.  role_id  is the id of the role the user is. It is a foreign key\n  and relates to the id's in the Role collection. By default\n  the general user is role.id = 1, and role.id = 2 is the\n  admin. Also note that we refer to the Role collection with\n  'roles' rather than the assigned backref 'role' since we\n  are referring to an individual column.", 
            "title": "Column Descriptions:"
        }, 
        {
            "location": "/models/#other-user-class-variables-and-methods", 
            "text": "Note that the following methods are actually available in your Jinja\ntemplates since they are attached to the user instance.  full_name  provides the full name of the user given a first and last\n  name  can  provides a really cool way of determining whether a user has\n  given permissions. See the Permissions class for more info. is_admin  is an implementation of  can  to test a user against\n  admin permissions.  password  This does not give a password if a user just\n  calls the method and throws an AttributeError. However\n  if someone chooses to set a password e.g.\n  u = User( password =  test  ) the second definition of\n  password method is run, taking the keyword arg (kwarg) as the\n  password to then call the generate_password_hash method and\n  set the password_hash property of the user to the generated\n  password.  verify_password  well...verifies a provided user plaintext password\n  against the password_hash in the user record. Uses the\n  check_password_hash method.  generate_confirmation_token  returns a cryptographically signed\n  string with encrypted user id under key  confirm . This will\n  expire in 7 days. Note that Serializer is actually\n  TimedJSONWebSerializer when looking for documentation.  generate_changed_email_token  also returns a cryptographically\n  signed string with encrypted user id under key  change_email \n  and a encrypted new_email parameter password into the method\n  containing the desired new email the user wants to replace the\n  old email with.  generate_password_reset_token  operates similarly to  generate_\n  confirmation_token . Generates token for password reset  NOTE: For context, the generate_..._token methods are used to create\na random string that will be later added to an email (usually) to the\nrequesting user.", 
            "title": "Other User Class Variables and Methods"
        }, 
        {
            "location": "/models/#confirm_account", 
            "text": "The confirm_account method will take in a token (which was presumably\ngenerated from the generate_confirmation_token method) and then return\nTrue if the provided token is valid (and can be decrypted with the\nSECRET_KEY and has not expired) AND the decrypted token has the key\n'confirm' with the id of the requesting user. If so, it flips the\n'confirmed' attribute of the requesting user to True.\nWill throw BadSignature of the token is invalid, will throw\nSignatureExpired if the token is past the expiration time.", 
            "title": "confirm_account"
        }, 
        {
            "location": "/models/#change_email", 
            "text": "The change_email method will take in a token (which was presumably\ngenerated from the generate_email_token method) and then return True\nTrue if the token is valid (see above method for explanation of 'valid')\nand contains the key 'change_email' with value = user id in addition to\nthe key 'new_email' with the new email address the user wants to change\ntheir email to. Before the new_email is committed to the session, a\nquery is performed on the User collection on all the emails to maintain\nthe unique constraint on the email columns. Then the user's 'email'\nattribute is set to the 'new_email' specified in the decrypted token.\nwill throw BadSignature if invalid token and SignatureExpired if the\ntoken is expired.", 
            "title": "change_email"
        }, 
        {
            "location": "/models/#anonymoususer", 
            "text": "We define a custom AnonymousUser class that represents a non-logged\nuser. It extends the AnonymousUserMixing provided by flask-loginmanager\nwe deny all permissions and affirm that this user is not an admin  class AnonymousUser(AnonymousUserMixin):\n    def can(self, _):\n        return False\n\n    def is_admin(self):\n        return False  login_manager.anonymous_user = AnonymousUser  We then register our custom AnonymousUser class as the default login_manager\nanonymous user class  @login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))  This is the default user_loader method for login_manager. This method\ndefines how to query for a user given a user_id from the user SESSION object.\nIt is pretty straightforward, it will query the User table and find the user\nwith ID equal to the user_id provided in the user SESSION", 
            "title": "AnonymousUser"
        }, 
        {
            "location": "/account/", 
            "text": "Routing (Account Routes)\n\n\nThis guide will be explaining the concept of routing by going through a file. We will be using \napp/account/views.py\n\n\nLogin\n\n\n@account.route('/login', methods=['GET', 'POST'])\ndef login():\n    \nLog in an existing user.\n\n    form = LoginForm()\n    if form.validate_on_submit():\n        user = User.query.filter_by(email=form.email.data).first()\n        if user is not None and user.password_hash is not None and \\\n                user.verify_password(form.password.data):\n            login_user(user, form.remember_me.data)\n            flash('You are now logged in. Welcome back!', 'success')\n            return redirect(request.args.get('next') or url_for('main.index'))\n        else:\n            flash('Invalid email or password.', 'form-error')\n    return render_template('account/login.html', form=form)\n\n\n\n\nAll routes are decorated with the name of the associated Blueprint along\nwith the .route prop with attributes of (name, methods=[]). For example\n\n@account.route('/login', method=['GET', 'POST'])\n creates a route accessible\nat \nyourdomain.com/account/login\n.\n\n\nThis route can accept either \nPOST\n or \nGET\n\nrequests which is appropriate since there is a form associated with the\nlogin process. This form is loaded from the forms.py file (in this case\nthe \nLoginForm()\n is loaded) and we then check if the form is valid\n(\nvalidate_on_submit\n) in that it is a valid POST request.\nWe grab the form field named 'email' and query the User database for the\nuser that has that email. Then we call the \nverify_password\n method\nfrom the User class for this specific user instance and check the hashed\npassword in the database against the password provided by the user which\nis hashed with the SECRET_KEY. If everything is fine, the Flask-login\nextendion performs a login_user action and sets the \nSESSION['user_id']\n\nequivalent to the user id provided from the user instance. If the\nform has remember_me set to True (ie checked) then that is passed along\nas a parameter in login_user.\n\n\nIf it was redirected to this /login page, their URL will have a parameter\ncalled \nnext\n containing the URL they need to be directed to after they\nlogin. Otherwise, they will just be sent to the main.index route\nThis is true for the admin as well. It is best to edit this functionality\nsince index pages should differ by user type. There is a flash sent as well\nif the request is successful.\n\n\nIf there is an error in the user checking process, then the user is kicked\nback to the account/login page with a flashed form error.\n\n\nIf this is a GET request, only the account/login page is rendered\n\n\nLogout\n\n\n@account.route('/logout')\n@login_required\ndef logout():\n    logout_user()\n    flash('You have been logged out.', 'info')\n    return redirect(url_for('main.index'))\n\n\n\n\nThe Flask-login Manager has a built in logout_user function that\nremoves the SESSION variables from the user's browser and logs out\nthe user completely", 
            "title": "Routing (account routes)"
        }, 
        {
            "location": "/account/#login", 
            "text": "@account.route('/login', methods=['GET', 'POST'])\ndef login():\n     Log in an existing user. \n    form = LoginForm()\n    if form.validate_on_submit():\n        user = User.query.filter_by(email=form.email.data).first()\n        if user is not None and user.password_hash is not None and \\\n                user.verify_password(form.password.data):\n            login_user(user, form.remember_me.data)\n            flash('You are now logged in. Welcome back!', 'success')\n            return redirect(request.args.get('next') or url_for('main.index'))\n        else:\n            flash('Invalid email or password.', 'form-error')\n    return render_template('account/login.html', form=form)  All routes are decorated with the name of the associated Blueprint along\nwith the .route prop with attributes of (name, methods=[]). For example @account.route('/login', method=['GET', 'POST'])  creates a route accessible\nat  yourdomain.com/account/login .  This route can accept either  POST  or  GET \nrequests which is appropriate since there is a form associated with the\nlogin process. This form is loaded from the forms.py file (in this case\nthe  LoginForm()  is loaded) and we then check if the form is valid\n( validate_on_submit ) in that it is a valid POST request.\nWe grab the form field named 'email' and query the User database for the\nuser that has that email. Then we call the  verify_password  method\nfrom the User class for this specific user instance and check the hashed\npassword in the database against the password provided by the user which\nis hashed with the SECRET_KEY. If everything is fine, the Flask-login\nextendion performs a login_user action and sets the  SESSION['user_id'] \nequivalent to the user id provided from the user instance. If the\nform has remember_me set to True (ie checked) then that is passed along\nas a parameter in login_user.  If it was redirected to this /login page, their URL will have a parameter\ncalled  next  containing the URL they need to be directed to after they\nlogin. Otherwise, they will just be sent to the main.index route\nThis is true for the admin as well. It is best to edit this functionality\nsince index pages should differ by user type. There is a flash sent as well\nif the request is successful.  If there is an error in the user checking process, then the user is kicked\nback to the account/login page with a flashed form error.  If this is a GET request, only the account/login page is rendered", 
            "title": "Login"
        }, 
        {
            "location": "/account/#logout", 
            "text": "@account.route('/logout')\n@login_required\ndef logout():\n    logout_user()\n    flash('You have been logged out.', 'info')\n    return redirect(url_for('main.index'))  The Flask-login Manager has a built in logout_user function that\nremoves the SESSION variables from the user's browser and logs out\nthe user completely", 
            "title": "Logout"
        }, 
        {
            "location": "/templates/", 
            "text": "Templating\n\n\nThis will cover various methods used in our jinja templates.\n\n\nBase.html\n\n\n{% import 'macros/nav_macros.html' as nav %}\n\n\n!DOCTYPE html\n\n\nhtml\n\n    \nhead\n\n        {% include 'partials/_head.html' %}\n        {# Any templates that extend this template can set custom_head_tags to add scripts to their page #}\n        {% block custom_head_tags %}{% endblock %}\n    \n/head\n\n    \nbody\n\n      {# Example dropdown menu setup. Uncomment lines to view\n        {% set dropdown = \n          [\n            ('account stuff',\n              [\n                ('account.login', 'login', 'sign in'),\n                ('account.logout', 'logout', 'sign out'),\n                ('2nd drop', [\n                  ('account.login', 'login 2', ''),\n                  ('3rd drop', [\n                    ('main.index', 'home 2', '')\n                  ])\n                ])\n              ]\n            ),\n            ('main.index', 'home 1', 'home')\n          ]\n        %}\n      #}\n\n        {% block nav %}\n          {# add dropdown variable here to the render_nav method to render dropdowns #}\n          {{ nav.render_nav(current_user) }}\n        {% endblock %}\n\n        {% include 'partials/_flashes.html' %}\n        {# When extended, the content block contains all the html of the webpage #}\n        {% block content %}\n        {% endblock %}\n\n        {# Implement CSRF protection for site #}\n        {% if csrf_token() %}\n            \ndiv style=\nvisibility: hidden; display: none\n\n                \ninput type=\nhidden\n name=\ncsrf_token\n value=\n{{ csrf_token() }}\n\n            \n/div\n\n        {% endif %}\n    \n/body\n\n\n/html\n\n\n\n\n\nMacros: Password Strength (\ncheck_password.html\n)\n\n\nRefer to \napp/templates/macros/check_password.html\n\n\nThis uses the zcvbn password checker to check the entropy of the password provided in the password field.\n   Given a specified field, the password checker will check the entropy of the field and disable the submit\n   button until the give 'level' is surpassed\n\n\nMacros: Form rendering (\nrender_form\n)\n\n\n{% macro render_form(form, method='POST', extra_classes='', enctype=None) %}\n    {% set flashes = {\n        'error':   get_flashed_messages(category_filter=['form-error']),\n        'warning': get_flashed_messages(category_filter=['form-check-email']),\n        'info':    get_flashed_messages(category_filter=['form-info']),\n        'success': get_flashed_messages(category_filter=['form-success'])\n    } %}\n\n    {{ begin_form(form, flashes, method=method, extra_classes=extra_classes, enctype=enctype) }}\n        {% for field in form if not (is_hidden_field(field) or field.type == 'SubmitField') %}\n            {{ render_form_field(field) }}\n        {% endfor %}\n\n        {{ form_message(flashes['error'], header='Something went wrong.', class='error') }}\n        {{ form_message(flashes['warning'], header='Check your email.', class='warning') }}\n        {{ form_message(flashes['info'], header='Information', class='info') }}\n        {{ form_message(flashes['success'], header='Success!', class='success') }}\n\n        {% for field in form | selectattr('type', 'equalto', 'SubmitField') %}\n            {{ render_form_field(field) }}\n        {% endfor %}\n    {{ end_form(form) }}\n{% endmacro %}\n\n\n\n\nRender a flask.ext.wtforms.Form object.\n\n\nParameters:\n    form          \u2013 The form to output.\n    method        \u2013 \nform\n method attribute (default 'POST')\n    extra_classes \u2013 The classes to add to the \nform\n.\n    enctype       \u2013 \nform\n enctype attribute. If None, will automatically be set to\n                    multipart/form-data if a FileField is present in the form. \n\n\n\n\nRender Form renders a form object. It calls the begin form macro. Initially\n   a 'flashes' variable is set with 'error', 'warning', 'info', 'success' which\n   have values gathered from the get_flashed_messages method from flask. Note\n   that all flashes are stored in SESSIOn with a category type. For most of our\n   purposes, we only have form-error and form-success as our flash types (the\n   second parameter in the flash function call seen in the views. \n\n\nThen the begin_form macro is called and for each form field in the provided\n   form render_form_field macro is called with the field. \n   All hidden fields (i.e. the CSRF field) and all submit fields is not rendered\n   at this fime in render_form_field. In the render_form_field\n   method, render_form_input is called for each input in the form field.\n\n\nAfter that, the form_message macro is called with each of the flash types.\n\n\nLastly, the submit field is rendered. And the form is closed with the end_form\n   macro\n\n\nMacros: Start Form (\nbegin_form\n)\n\n\nSet up the form, including hidden fields and error states.\nbegin_form is called from render_form. First a check is performed to check\nif there exists a field within the form with type equal to FileField. This \ncheck is performed via filter (\"|\") in Jinja. This initial check produces a\nfiltered object, the 'list' filter creates a iterable list which we can then\ncheck the length of with 'length \n 0'. So if this check passes, then the enctype\nmust be set to multipart/form-data to accomodate a file upload. Otherwise, there\nis no enctype.\n\n\nThen the form tag is created with a method default of POST, enctype decided by the\ncheck explained above. If there are errors (by field specific validator errors or \nif the flashes.error, flashes.warning, flashes.info, flashes.success is not None, \nthen that class is added to the overall class of the form (along with any specified\nextra_classes, default = ''). \n\n\nLastly the hidden_tags are rendered. WTForms includes in this method the rendering of\nthe hidden CSRF field. We don't have to worry about that. \n\n\nExample output:\n\n\nform action=\n method=\nPOST\n enctype=\nmultipart/form-data\n class=\nui form\n\n  \ndiv style=\ndisplay:none;\n\n    \ninput id=\ncsrf_token\n name=\ncsrf_token\n type=\nhidden\n value=\nSOME_CSRF_TOKEN_HERE\n \n\n\n\n\nMacros: Flash message to Form (\nform_message\n)\n\n\nRender a message for the form. This is called from the render_form macro.\n\n\nRecall the get_flashed_messages method. It will get the flash message from\nthe SESSION object with a given cateogory_filter. Within the render_form \nmacro, the flashes variable is set with attributes 'errors', 'success',\n'info', and 'warning'. The messages parameter for form_message contains the\nflash messages for the respective attribute specified in flashes['some_attr'].\n\n\nThe form_message macro is called after all form fields have been rendered,\nexcept for the Submit field. A div is created with class= 'ui CLASS message'\nclass being either error, success, info, or warning. This div is only created\nif there are messages for a given flashes type! For each of the messages in\nthe flashes type, the message is filtered to only contain escaped HTML chars\nand appended within the div ul as a list element.\n\n\nExample Output:\n\n\ndiv class=\nui error message\n\n  \ndiv class=\nheader\nSomething went wrong.\n/div\n\n  \nul class=\nlist\n\n    \nli\nInvalid email or password.\n/li\n\n  \n/ul\n\n\n/div\n\n\n\n\n\nMacros: Render a form field (\nrender_form_field\n)\n\n\nRender a field for the form. This is rather self explanatory.\n If the field is \n   a radio field (RadioField WTForms object) extra_classes has an added class of\n   'grouped fields' since all the options of a Radio Field must be styled in this\n   way to display together.\n   If there is a validation error on the form field, a error class is added to the\n   field div (to make the field colored red). Then the render_form_input macro is \n   called with field object itself as a parameter. Any validation errors are then\n   added with a sub-dev with content field.errors (we only show the first validation\n   error for the given error for simplicity) and filter for HTML safe chars.\n\n\nPartials: \n_flashes\n\n\nSee the macros/form_macros for extended explanation of the \n   get_flashed_messages(category_filter) method. This macro renders\n   general flash methods that appear at the top of the page. We render\n   by flash type and create a separate 'ui {{ class }} message' div\n   for each message within a specific flash type. Error = red,\n   warning = yellow, info = blue, success = green.\n\n\nPartials: \n_head\n\n\nThis method contains all the assett imports (i.e. imports for scripts and styles for the app)\n   Note that the asssets will be contained in the static/webassets-external folder when the app\n   is in debug mode.", 
            "title": "Templating"
        }, 
        {
            "location": "/templates/#templating", 
            "text": "This will cover various methods used in our jinja templates.", 
            "title": "Templating"
        }, 
        {
            "location": "/templates/#basehtml", 
            "text": "{% import 'macros/nav_macros.html' as nav %}  !DOCTYPE html  html \n     head \n        {% include 'partials/_head.html' %}\n        {# Any templates that extend this template can set custom_head_tags to add scripts to their page #}\n        {% block custom_head_tags %}{% endblock %}\n     /head \n     body \n      {# Example dropdown menu setup. Uncomment lines to view\n        {% set dropdown = \n          [\n            ('account stuff',\n              [\n                ('account.login', 'login', 'sign in'),\n                ('account.logout', 'logout', 'sign out'),\n                ('2nd drop', [\n                  ('account.login', 'login 2', ''),\n                  ('3rd drop', [\n                    ('main.index', 'home 2', '')\n                  ])\n                ])\n              ]\n            ),\n            ('main.index', 'home 1', 'home')\n          ]\n        %}\n      #}\n\n        {% block nav %}\n          {# add dropdown variable here to the render_nav method to render dropdowns #}\n          {{ nav.render_nav(current_user) }}\n        {% endblock %}\n\n        {% include 'partials/_flashes.html' %}\n        {# When extended, the content block contains all the html of the webpage #}\n        {% block content %}\n        {% endblock %}\n\n        {# Implement CSRF protection for site #}\n        {% if csrf_token() %}\n             div style= visibility: hidden; display: none \n                 input type= hidden  name= csrf_token  value= {{ csrf_token() }} \n             /div \n        {% endif %}\n     /body  /html", 
            "title": "Base.html"
        }, 
        {
            "location": "/templates/#macros-password-strength-check_passwordhtml", 
            "text": "Refer to  app/templates/macros/check_password.html  This uses the zcvbn password checker to check the entropy of the password provided in the password field.\n   Given a specified field, the password checker will check the entropy of the field and disable the submit\n   button until the give 'level' is surpassed", 
            "title": "Macros: Password Strength (check_password.html)"
        }, 
        {
            "location": "/templates/#macros-form-rendering-render_form", 
            "text": "{% macro render_form(form, method='POST', extra_classes='', enctype=None) %}\n    {% set flashes = {\n        'error':   get_flashed_messages(category_filter=['form-error']),\n        'warning': get_flashed_messages(category_filter=['form-check-email']),\n        'info':    get_flashed_messages(category_filter=['form-info']),\n        'success': get_flashed_messages(category_filter=['form-success'])\n    } %}\n\n    {{ begin_form(form, flashes, method=method, extra_classes=extra_classes, enctype=enctype) }}\n        {% for field in form if not (is_hidden_field(field) or field.type == 'SubmitField') %}\n            {{ render_form_field(field) }}\n        {% endfor %}\n\n        {{ form_message(flashes['error'], header='Something went wrong.', class='error') }}\n        {{ form_message(flashes['warning'], header='Check your email.', class='warning') }}\n        {{ form_message(flashes['info'], header='Information', class='info') }}\n        {{ form_message(flashes['success'], header='Success!', class='success') }}\n\n        {% for field in form | selectattr('type', 'equalto', 'SubmitField') %}\n            {{ render_form_field(field) }}\n        {% endfor %}\n    {{ end_form(form) }}\n{% endmacro %}  Render a flask.ext.wtforms.Form object.  Parameters:\n    form          \u2013 The form to output.\n    method        \u2013  form  method attribute (default 'POST')\n    extra_classes \u2013 The classes to add to the  form .\n    enctype       \u2013  form  enctype attribute. If None, will automatically be set to\n                    multipart/form-data if a FileField is present in the form.   Render Form renders a form object. It calls the begin form macro. Initially\n   a 'flashes' variable is set with 'error', 'warning', 'info', 'success' which\n   have values gathered from the get_flashed_messages method from flask. Note\n   that all flashes are stored in SESSIOn with a category type. For most of our\n   purposes, we only have form-error and form-success as our flash types (the\n   second parameter in the flash function call seen in the views.   Then the begin_form macro is called and for each form field in the provided\n   form render_form_field macro is called with the field. \n   All hidden fields (i.e. the CSRF field) and all submit fields is not rendered\n   at this fime in render_form_field. In the render_form_field\n   method, render_form_input is called for each input in the form field.  After that, the form_message macro is called with each of the flash types.  Lastly, the submit field is rendered. And the form is closed with the end_form\n   macro", 
            "title": "Macros: Form rendering (render_form)"
        }, 
        {
            "location": "/templates/#macros-start-form-begin_form", 
            "text": "Set up the form, including hidden fields and error states.\nbegin_form is called from render_form. First a check is performed to check\nif there exists a field within the form with type equal to FileField. This \ncheck is performed via filter (\"|\") in Jinja. This initial check produces a\nfiltered object, the 'list' filter creates a iterable list which we can then\ncheck the length of with 'length   0'. So if this check passes, then the enctype\nmust be set to multipart/form-data to accomodate a file upload. Otherwise, there\nis no enctype.  Then the form tag is created with a method default of POST, enctype decided by the\ncheck explained above. If there are errors (by field specific validator errors or \nif the flashes.error, flashes.warning, flashes.info, flashes.success is not None, \nthen that class is added to the overall class of the form (along with any specified\nextra_classes, default = '').   Lastly the hidden_tags are rendered. WTForms includes in this method the rendering of\nthe hidden CSRF field. We don't have to worry about that.   Example output:  form action=  method= POST  enctype= multipart/form-data  class= ui form \n   div style= display:none; \n     input id= csrf_token  name= csrf_token  type= hidden  value= SOME_CSRF_TOKEN_HERE", 
            "title": "Macros: Start Form (begin_form)"
        }, 
        {
            "location": "/templates/#macros-flash-message-to-form-form_message", 
            "text": "Render a message for the form. This is called from the render_form macro.  Recall the get_flashed_messages method. It will get the flash message from\nthe SESSION object with a given cateogory_filter. Within the render_form \nmacro, the flashes variable is set with attributes 'errors', 'success',\n'info', and 'warning'. The messages parameter for form_message contains the\nflash messages for the respective attribute specified in flashes['some_attr'].  The form_message macro is called after all form fields have been rendered,\nexcept for the Submit field. A div is created with class= 'ui CLASS message'\nclass being either error, success, info, or warning. This div is only created\nif there are messages for a given flashes type! For each of the messages in\nthe flashes type, the message is filtered to only contain escaped HTML chars\nand appended within the div ul as a list element.  Example Output:  div class= ui error message \n   div class= header Something went wrong. /div \n   ul class= list \n     li Invalid email or password. /li \n   /ul  /div", 
            "title": "Macros: Flash message to Form (form_message)"
        }, 
        {
            "location": "/templates/#macros-render-a-form-field-render_form_field", 
            "text": "Render a field for the form. This is rather self explanatory.\n If the field is \n   a radio field (RadioField WTForms object) extra_classes has an added class of\n   'grouped fields' since all the options of a Radio Field must be styled in this\n   way to display together.\n   If there is a validation error on the form field, a error class is added to the\n   field div (to make the field colored red). Then the render_form_input macro is \n   called with field object itself as a parameter. Any validation errors are then\n   added with a sub-dev with content field.errors (we only show the first validation\n   error for the given error for simplicity) and filter for HTML safe chars.", 
            "title": "Macros: Render a form field (render_form_field)"
        }, 
        {
            "location": "/templates/#partials-_flashes", 
            "text": "See the macros/form_macros for extended explanation of the \n   get_flashed_messages(category_filter) method. This macro renders\n   general flash methods that appear at the top of the page. We render\n   by flash type and create a separate 'ui {{ class }} message' div\n   for each message within a specific flash type. Error = red,\n   warning = yellow, info = blue, success = green.", 
            "title": "Partials: _flashes"
        }, 
        {
            "location": "/templates/#partials-_head", 
            "text": "This method contains all the assett imports (i.e. imports for scripts and styles for the app)\n   Note that the asssets will be contained in the static/webassets-external folder when the app\n   is in debug mode.", 
            "title": "Partials: _head"
        }
    ]
}